To create a Hash table that incorporates seprate chaining a class for Linked Lists must be made. In order for a Linked List to be used we must also make a class for Nodes that make up the Linked List. Starting off with the Node class we must initializa (__init__) with key value pair (keyVal) and also the next node edge that will connect this node to the next. WIthin the Node class we have setNext, getKey, getValue, updateTuple, and getNext. setNext will take in the next node (nextNode) and set the next value from our node equal to the next node (self.next = nextNode). getKey simply returns the key from the tuple in the node. getValue is another simple function that returns the value of the tuple which is in position [1] of the tuple. updateTuple will take in a key and a value. The current node will then update the current node with the new value since the current node's key is the same. However we must initialize the whole tuple because the value within a tuple canont be changed without the entire tuple being changed. getNext will return the next node we have set for our node (self.next). Moving onto the Linked List class we initialize the class with just a head node (headNode). The functions that make up the Linked List class are insertNode, deleteNode, getItem, and getKeys. insertNode inserts a new node. The funciton takes a new node (newNode) and sets the next node (setNext) to the head of the current node (self.headNode). Then the head node of the current node is set to the new node. deleteNode takes a key and deletes the node with the given key. To do so, current is set to the head (self.headNode) and previous is set to None because the fnction will traverse the linked list starting from the first head which has no previous node. While current does not equal None the loop checks if the if the current node key is equal to the input key. If the keys are equal then the loop breaks. If the keys are not equal then precious is assigned to current node and current node is assigned to the next node (getNext()). After traversing through the linked list and finding the tuple equal to the current key the tuple must be removed. If previous is equal to none then the node being deleted is the head so the next node to the head is set to the current nodes next node. If previous is not equal to none then previous is set to the next node of the current node passing the node being deleted. getItem takes a key as input and sets the current node to the head node (headNode). While current exists the loop traverses and finds the node with the key in the tuple. If the key in the tuple is equal to the key input then the function returns the current node. If the key does not equal the current node then the loop traverses the linked list until it finds the correct node. getKeys will traverse the nodes in the linked list and creaes an array with the keys. The function appends the keys from each node and moves onto the next node while current exists. Finally moving into the Hashtable. To initialize the hash table with the dict input there must be an initialization of the hashTable with an arbitrary length. After creating the hasTable full of None elements a count must be initialized so later the table can be expanded when a load factor is above a given percentage. To initialize the hash table a for loop is used making each dict input a tuple and then being an input for set item function (__setitem__). Hashtable has the functions getitem, setitem, rehash, delitem, compress, and finally keys. getItem takes a key and finds the tuple in the has table that matches the input key and returns the tuple, else the function returns None if the key cannot be found. setItem takes a key and value pair and puts the pair in the hash table. First off the hash value must be computed and used to find the index where the pair will be inserted. Then an if statement is used to see if the key exists in the hash table already. if the key does not exists then a new linked list must be created so that the tuple can be placed within the linked list in the index. Following the insertion of a new linked list means that count must be incremented and checked against the load factor to see if the hash table needs to be expanded times two. On the other hand if the key already exists then the linked list must be searched to update the old key. rehash takes in the current hash table and this function is only called when the load factor is above the desired percentage. rehash will create a new table (newTable) that is twice as big as the old table. The old table (oldTable) is then set to the current hash table because it needs to be traversed and rehashed into the newly created hash table because all of the old indexes are bad. delitem takes a key and the hastable is searched to find the key that is equal to the input key and then the tupe found is deleted from the hash table. This is done by calling deleteNode which is a function in the Linked List class. compress takes in a hash value (hashValue) and makes the hash equal to an index that is within the hash tables range. keys simply creates an array and searches through the hash table and gets all the keys from each index in each linked list and combines them into a single array. The array of keys is then returned. That is all it takes to finish the lab project for hash tables. 