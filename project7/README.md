Nick Palumbo

find_paths takes in a grid and points. The function will create a closed list which is a list of all the points reached. An open list is also created that is a list of all the points from the input to the funciton. A paths list is created to hold the shortest path once found for each point. Making an instantiation of a graph is done so that it can be used to pass the graph into the search function. While the open list is not empty a while loop will execute and first pop off the last element of the open list and make it the queue. The starting point will be the first element within the queue tuple and the target point will be the second element in the queue tuple. The search function takes the graph, the starting point, and the target point. Within the search a priority queue is made so that each point will be used. Making the first used the closest point. The priority queue starts out empty and then the input strating point is inserted into the priority queue so that we have a starting point to process the rest of the points. A dictionary is made for past points, and the cost so far within the path. The starting point in the past dictionary will have the value None because it is the starting point. The cost dictionary will be set to 0 because the function has not processed any other points yet. A while loop starts and first makes sure that the priority queue is not empty. If the priority queue is empty then the function will end and return the two dictionaries made at the start (past point, costs). If the current point is equal to the target point then the loop will break because the path is finished. However if the path is not finished then an if statement creates a list of adjacent points to be chacked from the current queue edge. The cost is then updated to a new cost that is equal to the cost so far of the current queued point and added to the cost of the entire path in the graph. Next is an if statement that checks if the adjacent edge being processed is not in the cost so far dictionary or if the new cost is less than the cost so far of the current adjacent point being processed. This is because if the point being processed is in the dictionary for cost and the new cost is greater than the cost so far of the current point then the current point being processed has already been processed. If the processed edge is not in the cost dictionary or the new cost is less than the cost already entered for the processed point then the cost for the point will be updated in the cost dictionary to equal the new cost. A priority value is then made that is the sum of the new cost and the heuristic value. The heuristic value is calculated by taking the goal and the current point and finding the distance between them. This will help find the most optimal path between the current point and target point. Now the priority queue is updated by inserting a tuple with the current node and priority value. Then the past point dictionary is then updated making the current point key have the value of the parent point that was used to find the current point. Once all of the possible adjacent points are processed the loop breaks and the dictionary for past points and the dictionary for cost is returned. The values returned are then appended to the paths list so that each smallest path is inputed into the list of paths. The closed list is then updated with the current queue point and a new queue is then popped off the open list until the open list is empty. 